#!/usr/bin/env bash
#
# tribe — Swarm orchestration CLI for autonomous product development
#
# Usage: ./swarm/tribe <command> [options]
#
# Commands:
#   init                    Initialize project for swarm development
#   validate <specs-dir>    Cross-validate all specs for consistency
#   plan <spec-file> [opts] Decompose a spec into a task DAG + contract
#   verify                  Blind-verify the plan against the product spec
#   run [options]           Execute pending tasks with parallel agents
#   status                  Show swarm state and progress
#   coherence               Check cross-task consistency before integration
#   integrate               Merge completed branches into main
#   review [--task-id ID]   Run code review on completed tasks
#   retry --task-id ID      Retry a failed task with human guidance
#   recover                 Recover from crashed/stale state
#   guardian [spec-file]     Run Product Guardian vision check
#   help                    Show this help message

set -euo pipefail

# ── Bootstrap ────────────────────────────────────────────────────
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

source "${SCRIPT_DIR}/lib/config.sh"
source "${SCRIPT_DIR}/lib/log.sh"
source "${SCRIPT_DIR}/lib/git.sh"
source "${SCRIPT_DIR}/lib/claude.sh"
source "${SCRIPT_DIR}/lib/tasks.sh"
source "${SCRIPT_DIR}/lib/grounding.sh"
source "${SCRIPT_DIR}/lib/gates.sh"
source "${SCRIPT_DIR}/lib/lock.sh"
source "${SCRIPT_DIR}/lib/features.sh"

# ── Helpers ──────────────────────────────────────────────────────

tribe_help() {
    echo ""
    echo -e "${BOLD}tribe${RESET} — Swarm orchestration for autonomous product development"
    echo ""
    echo -e "${BOLD}USAGE${RESET}"
    echo "    ./swarm/tribe <command> [options]"
    echo ""
    echo -e "${BOLD}WORKFLOW${RESET}"
    echo -e "    ${DIM}1.${RESET} ${CYAN}init${RESET}       → ${DIM}Initialize project${RESET}"
    echo -e "    ${DIM}2.${RESET} ${CYAN}validate${RESET}   → ${DIM}Cross-validate specs${RESET}"
    echo -e "    ${DIM}3.${RESET} ${CYAN}plan${RESET}       → ${DIM}Guardian gate → Decompose spec into task DAG + contract${RESET}"
    echo -e "    ${DIM}4.${RESET} ${CYAN}verify${RESET}     → ${DIM}Blind-check plan against spec${RESET}"
    echo -e "    ${DIM}5.${RESET} ${CYAN}run${RESET}        → ${DIM}Execute tasks with parallel agents${RESET}"
    echo -e "    ${DIM}6.${RESET} ${CYAN}review${RESET}     → ${DIM}Code review + Guardian gate on completed tasks${RESET}"
    echo -e "    ${DIM}7.${RESET} ${CYAN}coherence${RESET}  → ${DIM}Cross-task consistency check${RESET}"
    echo -e "    ${DIM}8.${RESET} ${CYAN}integrate${RESET}  → ${DIM}Merge + regression + contract + Guardian gate${RESET}"
    echo ""
    echo -e "${BOLD}COMMANDS${RESET}"
    echo -e "    ${CYAN}init${RESET}                        Initialize project for swarm development"
    echo -e "    ${CYAN}validate${RESET} <specs-dir>         Cross-validate all specs for consistency"
    echo -e "    ${CYAN}plan${RESET} <spec-file> [opts]      Decompose a product spec into task DAG + contract"
    echo -e "    ${CYAN}verify${RESET}                       Blind-verify plan against product spec"
    echo -e "    ${CYAN}run${RESET}  [options]               Execute pending tasks with parallel agents"
    echo -e "    ${CYAN}status${RESET}                       Show swarm state and progress"
    echo -e "    ${CYAN}coherence${RESET}                    Cross-task consistency check pre-integration"
    echo -e "    ${CYAN}integrate${RESET}                    Merge completed branches + regression + contract"
    echo -e "    ${CYAN}review${RESET} [--task-id ID]        Run code review on completed tasks"
    echo -e "    ${CYAN}retry${RESET}  --task-id ID --context Retry a failed task with human guidance"
    echo -e "    ${CYAN}recover${RESET}                      Recover from crashed/stale swarm state"
    echo -e "    ${CYAN}clean${RESET}   [logs|all]            Remove logs or entire .tribe/ state"
    echo -e "    ${CYAN}guardian${RESET} [spec-file]           Run Product Guardian vision check"
    echo -e "    ${CYAN}help${RESET}                         Show this help message"
    echo ""
    echo -e "${BOLD}GLOBAL OPTIONS${RESET}"
    echo -e "    --feature NAME              Target a specific feature (auto-detected if omitted)"
    echo ""
    echo -e "${BOLD}PLAN OPTIONS${RESET}"
    echo -e "    --specs-dir DIR             Directory with related specs for cross-referencing"
    echo ""
    echo -e "${BOLD}RUN OPTIONS${RESET}"
    echo -e "    --max-parallel N            Max concurrent agents (default: ${DEFAULT_MAX_PARALLEL})"
    echo -e "    --model MODEL               Developer model: sonnet|opus|haiku (default: ${MODEL_SUPPORT})"
    echo ""
    echo -e "${BOLD}RETRY OPTIONS${RESET}"
    echo -e "    --task-id ID                Target a specific failed task (required)"
    echo -e "    --context \"...\"             Human guidance for the retry (required)"
    echo -e "    --escalate                  Upgrade model on retry (sonnet→opus)"
    echo ""
    echo -e "${BOLD}GUARDIAN OPTIONS${RESET}"
    echo -e "    SKIP_GUARDIAN=true             Skip guardian gates in plan/review/integrate"
    echo ""
    echo -e "${BOLD}PARALLEL FEATURES${RESET}"
    echo -e "    Each ${CYAN}tribe plan${RESET} creates an isolated feature namespace."
    echo -e "    Run multiple features in parallel across separate sessions:"
    echo -e "    ${DIM}Session 1:${RESET} ./swarm/tribe plan specs/tech/f3-projects.md && ./swarm/tribe run"
    echo -e "    ${DIM}Session 2:${RESET} ./swarm/tribe plan specs/tech/f4-tribes.md && ./swarm/tribe run"
    echo -e "    Use ${CYAN}--feature${RESET} to target a specific feature, or omit to auto-detect."
    echo ""
    echo -e "${BOLD}EXAMPLES${RESET}"
    echo "    ./swarm/tribe init"
    echo "    ./swarm/tribe validate specs/"
    echo "    ./swarm/tribe plan specs/product/f3-projects.md --specs-dir specs/"
    echo "    ./swarm/tribe run"
    echo "    ./swarm/tribe run --feature f4-tribes --max-parallel 3"
    echo "    ./swarm/tribe status"
    echo "    ./swarm/tribe review --feature f3-projects"
    echo "    ./swarm/tribe coherence"
    echo "    ./swarm/tribe integrate"
    echo "    ./swarm/tribe clean feature f3-projects"
    echo ""
}

# ── Commands ─────────────────────────────────────────────────────

cmd_init() {
    log_header "Initializing Tribe"

    # 1. Git repo
    git_ensure_repo
    log_success "Git repository ready"

    # 2. Directory structure
    mkdir -p "$FEATURES_DIR" "$LOGS_DIR" src tests
    log_success "Directory structure created"

    # 3. .gitignore
    if ! grep -q '.tribe/features/' "$TRIBE_ROOT/.gitignore" 2>/dev/null; then
        cat >> "$TRIBE_ROOT/.gitignore" << 'EOF'

# Tribe runtime state
.tribe/logs/
.tribe/features/*/logs/
.tribe/features/*/state.json
.tribe/features/*/failure_history.jsonl
.tribe/active_feature
.tribe/state.json
.tribe/running/
.tribe/worktrees/
EOF
        log_success "Updated .gitignore"
    fi

    # 4. Runtime state (global — for validate and cross-feature use)
    echo '{"status":"idle","agents":[],"started_at":null}' | jq '.' > "${TRIBE_DIR}/state.json"
    log_success "Runtime state initialized"

    # 5. CLAUDE.md
    if [[ ! -f "$CLAUDE_MD" ]]; then
        local project_name
        project_name=$(basename "$TRIBE_ROOT")
        sed "s/{{PROJECT_NAME}}/${project_name}/g" "${TEMPLATES_DIR}/claude-md.md" > "$CLAUDE_MD"
        log_success "Created CLAUDE.md — ${DIM}customize this file!${RESET}"
    else
        log_info "CLAUDE.md already exists, skipping"
    fi

    # 6. Initial commit
    (cd "$TRIBE_ROOT" && git add -A && git commit -m "tribe init: project scaffold" 2>/dev/null) || true

    echo ""
    log_success "Tribe initialized! Next steps:"
    echo -e "  1. Edit ${CYAN}CLAUDE.md${RESET} with your project conventions"
    echo -e "  2. Create a product spec: ${CYAN}cp swarm/templates/spec.md my-spec.md${RESET}"
    echo -e "  3. Plan your tasks: ${CYAN}./swarm/tribe plan my-spec.md${RESET}"
    echo ""
}

cmd_validate() {
    local specs_dir="${1:-}"

    if [[ -z "$specs_dir" ]]; then
        log_error "Usage: tribe validate <specs-dir>"
        exit 1
    fi

    if [[ ! -d "$specs_dir" ]]; then
        if [[ -d "${TRIBE_ROOT}/${specs_dir}" ]]; then
            specs_dir="${TRIBE_ROOT}/${specs_dir}"
        else
            log_error "Specs directory not found: $specs_dir"
            exit 1
        fi
    fi

    log_header "Validating Specs"

    # Gather all spec files
    local spec_files=""
    local file_count=0
    while IFS= read -r -d '' f; do
        local relpath="${f#${TRIBE_ROOT}/}"
        spec_files+=$'\n\n'"--- FILE: ${relpath} ---"$'\n'"$(cat "$f")"
        ((file_count++))
    done < <(find "$specs_dir" -name '*.md' -type f -print0 | sort -z)

    if [[ $file_count -eq 0 ]]; then
        log_error "No .md files found in $specs_dir"
        exit 1
    fi

    log_step "Found ${file_count} spec files"
    log_step "Sending to Validator agent..."
    echo ""

    local validator_output
    validator_output=$(claude_run \
        "${AGENTS_DIR}/validator.md" \
        "Cross-validate the following ${file_count} specification files for consistency, completeness, and missing relationships:${spec_files}" \
        "$MODEL_SUPPORT" \
        "$AGENT_TOOLS_READONLY")

    echo "$validator_output"
    echo ""

    # Save validation report
    echo "$validator_output" > "${LOGS_DIR}/validation.log"
    log_success "Validation report saved to ${LOGS_DIR}/validation.log"

    # Check status
    local status
    status=$(echo "$validator_output" | jq -r '.status' 2>/dev/null || echo "unknown")

    if [[ "$status" == "fail" ]]; then
        echo ""
        log_error "Validation FAILED — fix critical gaps before running 'tribe plan'"
        local gap_count
        gap_count=$(echo "$validator_output" | jq '.critical_gaps | length' 2>/dev/null || echo "?")
        log_error "${gap_count} critical gap(s) found"
        exit 1
    elif [[ "$status" == "pass" ]]; then
        echo ""
        log_success "Validation PASSED — specs are consistent"
    else
        log_warn "Could not parse validation status. Review the report manually."
    fi

    echo ""
}

# ── Gather related specs for cross-referencing ────────────────

_gather_related_specs() {
    local specs_dir="$1"
    local exclude_file="$2"
    local related=""

    if [[ -z "$specs_dir" ]] || [[ ! -d "$specs_dir" ]]; then
        echo ""
        return
    fi

    while IFS= read -r -d '' f; do
        # Skip the primary spec file
        if [[ "$(realpath "$f")" == "$(realpath "$exclude_file")" ]]; then
            continue
        fi
        local relpath="${f#${TRIBE_ROOT}/}"
        related+=$'\n\n'"--- RELATED SPEC: ${relpath} ---"$'\n'"$(cat "$f")"
    done < <(find "$specs_dir" -name '*.md' -type f -print0 | sort -z)

    echo "$related"
}

# ── Store the primary spec file path for downstream commands ──
# Uses FEATURE_DIR when a feature is active, otherwise TRIBE_DIR fallback.

_save_spec_path() {
    local spec_file="$1"
    local dir="${FEATURE_DIR:-${TRIBE_DIR}}"
    echo "$spec_file" > "${dir}/spec_path"
}

_get_spec_path() {
    local dir="${FEATURE_DIR:-${TRIBE_DIR}}"
    if [[ -f "${dir}/spec_path" ]]; then
        cat "${dir}/spec_path"
    fi
}

cmd_plan() {
    local spec_file="${1:-}"
    shift || true
    local specs_dir=""

    # Parse options
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --specs-dir) specs_dir="$2"; shift 2 ;;
            *) log_error "Unknown option: $1"; exit 1 ;;
        esac
    done

    if [[ -z "$spec_file" ]]; then
        log_error "Usage: tribe plan <spec-file> [--specs-dir DIR]"
        exit 1
    fi

    if [[ ! -f "$spec_file" ]]; then
        # Try relative to TRIBE_ROOT
        if [[ -f "${TRIBE_ROOT}/${spec_file}" ]]; then
            spec_file="${TRIBE_ROOT}/${spec_file}"
        else
            log_error "Spec file not found: $spec_file"
            exit 1
        fi
    fi

    # Resolve specs_dir
    if [[ -n "$specs_dir" ]] && [[ ! -d "$specs_dir" ]]; then
        if [[ -d "${TRIBE_ROOT}/${specs_dir}" ]]; then
            specs_dir="${TRIBE_ROOT}/${specs_dir}"
        else
            log_warn "Specs directory not found: $specs_dir — proceeding without cross-references"
            specs_dir=""
        fi
    fi

    # ── Activate feature namespace ────────────────────────────────
    local feature_name="${GLOBAL_FEATURE:-}"
    if [[ -z "$feature_name" ]]; then
        feature_name=$(feature_name_from_spec "$spec_file")
    fi
    feature_activate "$feature_name"
    feature_set_active "$feature_name"
    log_info "Feature: ${CYAN}${feature_name}${RESET}"

    # Save spec path for verify and review commands
    _save_spec_path "$spec_file"

    log_header "Planning Task DAG"
    log_step "Reading spec: ${CYAN}${spec_file}${RESET}"

    local spec_content
    spec_content=$(cat "$spec_file")

    # ── Pre-Plan Guardian Gate ─────────────────────────────────────
    # Check: does this spec belong in the product?
    log_step "Running pre-plan vision check..."
    _run_guardian "pre-plan" "$spec_content" "$spec_file" || {
        local guardian_rc=$?
        if [[ $guardian_rc -eq 1 ]]; then
            log_error "Product Guardian REJECTED this spec — it conflicts with the product vision"
            echo -e "Review the guardian report and either:"
            echo -e "  1. Fix the spec to align with the vision"
            echo -e "  2. Override with ${CYAN}SKIP_GUARDIAN=true tribe plan ...${RESET} (use with caution)"
            if [[ "${SKIP_GUARDIAN:-}" != "true" ]]; then
                exit 1
            else
                log_warn "SKIP_GUARDIAN=true — proceeding despite rejection"
            fi
        fi
        # guardian_rc == 2 means flagged — warn but continue
    }
    echo ""

    # ── Spec-Codebase Grounding ────────────────────────────────────
    # Check: does the spec accurately describe the current codebase?
    SPEC_CODEBASE_CONTEXT=""
    spec_grounding_check "$spec_file"

    # Gather related specs for cross-referencing
    local related_specs=""
    if [[ -n "$specs_dir" ]]; then
        log_step "Gathering related specs from: ${CYAN}${specs_dir}${RESET}"
        related_specs=$(_gather_related_specs "$specs_dir" "$spec_file")
        if [[ -n "$related_specs" ]]; then
            log_step "Cross-referencing with related specs"
        fi
    fi

    log_step "Sending to Architect agent..."
    echo ""

    # Build the message with primary spec, codebase context, and related specs
    local architect_message="Here is the product specification to decompose into tasks:\n\n${spec_content}"
    if [[ -n "$SPEC_CODEBASE_CONTEXT" ]]; then
        architect_message+="\n\n${SPEC_CODEBASE_CONTEXT}"
    fi
    if [[ -n "$related_specs" ]]; then
        architect_message+="\n\n## Related Specs (cross-reference these for entity relationships)\n${related_specs}"
    fi

    # Run architect agent
    local architect_output
    architect_output=$(claude_run_json \
        "${AGENTS_DIR}/architect.md" \
        "$architect_message" \
        "${TEMPLATES_DIR}/task.json" \
        "$MODEL_PLANNING")

    # Save raw output for debugging
    echo "$architect_output" > "${LOGS_DIR}/architect-raw.log"

    # ── Extract tasks and contract from architect output ──────────

    local parsed_architect
    parsed_architect=$(parse_agent_json "$architect_output") || {
        log_error "Could not extract JSON from architect output"
        log_error "Raw output saved to ${LOGS_DIR}/architect-raw.log"
        exit 1
    }

    local tasks_json=""
    local contract_json=""

    # Handle {tasks: [...], contract: {...}} wrapper or bare array
    if echo "$parsed_architect" | jq -e '.tasks | type == "array"' &>/dev/null; then
        tasks_json=$(echo "$parsed_architect" | jq '.tasks')
        contract_json=$(echo "$parsed_architect" | jq '.contract // empty')
    elif echo "$parsed_architect" | jq -e 'type == "array"' &>/dev/null; then
        tasks_json="$parsed_architect"
    else
        log_error "Architect output is not a task array or {tasks: [...]}"
        log_error "Raw output saved to ${LOGS_DIR}/architect-raw.log"
        exit 1
    fi

    architect_output="$tasks_json"

    # Save contract if present
    if [[ -n "$contract_json" ]] && echo "$contract_json" | jq -e '.' &>/dev/null; then
        echo "$contract_json" | jq '.' > "${CONTRACT_FILE}"
        log_success "Contract saved to ${TRIBE_DIR}/contract.json"
    else
        log_warn "No contract produced by Architect — verification will be limited"
        log_warn "Consider re-running plan or manually creating .tribe/contract.json"
    fi

    # Clear existing tasks
    rm -f "${TASKS_DIR}"/*.json

    # Parse and create task files
    local task_count
    task_count=$(echo "$architect_output" | jq 'length')

    log_step "Creating ${task_count} tasks..."
    echo ""

    # Check for file conflicts between parallel tasks
    local conflict_warnings=""

    local i=0
    while [[ $i -lt $task_count ]]; do
        local task
        task=$(echo "$architect_output" | jq ".[$i]")

        local id title description criteria depends_on model files_touched
        id=$(echo "$task" | jq -r '.id')
        title=$(echo "$task" | jq -r '.title')
        description=$(echo "$task" | jq -r '.description')
        criteria=$(echo "$task" | jq -r '.acceptance_criteria')
        depends_on=$(echo "$task" | jq -c '.depends_on // []')
        model=$(echo "$task" | jq -r --arg def "$MODEL_SUPPORT" '.agent_model // $def')
        files_touched=$(echo "$task" | jq -c '.files_touched // []')

        task_create "$id" "$title" "$description" "$criteria" "$depends_on" "$model"

        # Store files_touched in the task file
        if [[ "$files_touched" != "[]" ]]; then
            task_update_raw "$id" "files_touched" "$files_touched"
        fi

        ((i++))
    done

    log_success "Task DAG created with ${task_count} tasks"
    echo ""

    # Display task graph
    log_header "Task Graph"
    task_print_graph
    echo ""
    task_print_summary
    echo ""

    echo -e "${DIM}Review tasks in ${TASKS_DIR}/${RESET}"
    echo -e "${DIM}Next: ${CYAN}./swarm/tribe verify${RESET} to validate the plan against the spec${RESET}"
    echo ""
}

# ── Verify: blind plan verification against product spec ─────

cmd_verify() {
    _require_feature "$GLOBAL_FEATURE"
    log_header "Verifying Plan Against Spec"

    # Check prerequisites
    local total
    total=$(task_count_total)
    if [[ "$total" -eq 0 ]]; then
        log_error "No tasks found. Run 'tribe plan <spec>' first."
        exit 1
    fi

    local spec_file
    spec_file=$(_get_spec_path)
    if [[ -z "$spec_file" ]] || [[ ! -f "$spec_file" ]]; then
        log_error "Product spec not found. Run 'tribe plan <spec-file>' first."
        exit 1
    fi

    log_step "Reading product spec: ${CYAN}${spec_file}${RESET}"
    local spec_content
    spec_content=$(cat "$spec_file")

    # Gather the task plan
    log_step "Gathering task plan (${total} tasks)..."
    local task_plan=""
    for f in "${TASKS_DIR}"/*.json; do
        [[ -f "$f" ]] || continue
        local id title desc criteria deps files
        id=$(jq -r '.id' "$f")
        title=$(jq -r '.title' "$f")
        desc=$(jq -r '.description' "$f")
        criteria=$(jq -r '.acceptance_criteria' "$f")
        deps=$(jq -r '.depends_on | join(", ")' "$f")
        files=$(jq -r '.files_touched // [] | join(", ")' "$f")

        task_plan+="### Task ${id}: ${title}
Description: ${desc}
Acceptance Criteria: ${criteria}
Depends On: ${deps}
Files: ${files}

"
    done

    # Gather contract if it exists
    local contract_section=""
    if [[ -f "${CONTRACT_FILE}" ]]; then
        contract_section="
## Data Model Contract
$(cat "${CONTRACT_FILE}")
"
    fi

    # Build verification message — spec and plan ONLY, no architect reasoning
    local verify_message="## Product Specification

${spec_content}

## Task Plan

${task_plan}
${contract_section}

Verify this plan against the product specification. Read the spec FIRST, form your own understanding, THEN check the plan."

    log_step "Sending to Plan Verifier agent (blind check)..."
    echo ""

    local verify_output
    verify_output=$(claude_run \
        "${AGENTS_DIR}/plan-verifier.md" \
        "$verify_message" \
        "$MODEL_PLANNING" \
        "$AGENT_TOOLS_READONLY")

    echo "$verify_output"
    echo ""

    # Save verification report
    echo "$verify_output" > "${LOGS_DIR}/plan-verification.log"
    log_success "Verification report saved to ${LOGS_DIR}/plan-verification.log"

    # Check status
    local status
    status=$(echo "$verify_output" | jq -r '.status' 2>/dev/null || echo "unknown")

    if [[ "$status" == "fail" ]]; then
        echo ""
        log_error "Plan verification FAILED — the plan may not deliver what the spec requires"
        local failure_count
        failure_count=$(echo "$verify_output" | jq '.critical_failures | length' 2>/dev/null || echo "?")
        log_error "${failure_count} critical failure(s) found"
        echo ""
        echo -e "Options:"
        echo -e "  1. Fix the spec or re-run ${CYAN}tribe plan${RESET} with adjustments"
        echo -e "  2. Review the failures and proceed if they're false positives"
        echo ""
        exit 1
    elif [[ "$status" == "pass" ]]; then
        echo ""
        log_success "Plan verification PASSED"
        echo -e "Next: ${CYAN}./swarm/tribe run${RESET} to execute tasks"
    else
        log_warn "Could not parse verification status. Review the report manually."
    fi

    echo ""
}

cmd_run() {
    _require_feature "$GLOBAL_FEATURE"

    local max_parallel=$DEFAULT_MAX_PARALLEL
    local model=$MODEL_SUPPORT

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --max-parallel) max_parallel="$2"; shift 2 ;;
            --model)        model="$2"; shift 2 ;;
            *) log_error "Unknown option: $1"; exit 1 ;;
        esac
    done

    # ── Acquire exclusive lock ────────────────────────────────────
    swarm_acquire_lock "run" || exit 1

    # ── Hard gate: timeout command is required ────────────────────
    require_timeout_cmd || exit 1

    log_header "Running Swarm"
    log_info "Max parallel: ${max_parallel} | Model: ${model}"

    # Check for circular dependencies before starting
    if ! task_topo_sort > /dev/null; then
        log_error "Cannot run: circular dependencies in task graph. Fix depends_on fields."
        exit 1
    fi

    # Ensure working tree is committed so task branches see all files
    git_create_baseline

    # Verify tasks exist
    local total
    total=$(task_count_total)
    if [[ "$total" -eq 0 ]]; then
        log_error "No tasks found. Run 'tribe plan <spec>' first."
        exit 1
    fi

    # Check for stale state
    local current_state
    current_state=$(jq -r '.status' "$STATE_FILE" 2>/dev/null || echo "idle")
    if [[ "$current_state" == "running" ]]; then
        log_warn "Swarm state is 'running' — may be stale from a previous crash."
        log_warn "Run ${CYAN}tribe recover${RESET} first, or press Ctrl+C to abort."
        sleep "$STALE_STATE_PAUSE"
    fi

    # Update state
    jq -n \
        --arg status "running" \
        --arg started "$(date -u +%Y-%m-%dT%H:%M:%SZ)" \
        '{status: $status, agents: [], started_at: $started, failure_history: []}' > "$STATE_FILE"

    # Detect the base branch all task branches fork from
    local main_branch
    main_branch=$(git_main_branch)

    # ── Agent tracking via files (bash 3 compatible) ───────────
    local running_dir="${FEATURE_DIR}/running"
    rm -rf "$running_dir"
    mkdir -p "$running_dir"

    _running_count() {
        local count=0
        for f in "$running_dir"/*.pid; do
            [[ -f "$f" ]] && ((count++))
        done
        echo "$count"
    }

    _running_task_ids() {
        for f in "$running_dir"/*.pid; do
            [[ -f "$f" ]] || continue
            basename "$f" .pid
        done
    }

    # ── Failure tracking for pattern detection ─────────────────
    local failure_log="${FEATURE_DIR}/failure_history.jsonl"
    > "$failure_log"  # Clear

    _record_failure() {
        local task_id="$1"
        local error="$2"
        jq -nc --arg tid "$task_id" --arg err "$error" --arg ts "$(date -u +%Y-%m-%dT%H:%M:%SZ)" \
            '{task_id: $tid, error: $err, timestamp: $ts}' >> "$failure_log"
    }

    _failure_count() {
        wc -l < "$failure_log" 2>/dev/null | tr -d ' '
    }

    # ── Main orchestration loop ──────────────────────────────────
    while true; do
        # Check for completed agents
        for pid_file in "$running_dir"/*.pid; do
            [[ -f "$pid_file" ]] || continue
            local task_id pid
            task_id=$(basename "$pid_file" .pid)
            pid=$(cat "$pid_file")

            # Check if done marker exists (agent finished) or process stopped
            local output_file="${LOGS_DIR}/${task_id}.log"
            local done_marker="${output_file}.done"

            if [[ -f "$done_marker" ]] || ! claude_is_running "$pid"; then
                # Wait briefly for file writes to flush
                sleep "$COMPLETION_FLUSH_WAIT"

                # ── Check for crash: process gone but no .done marker ──
                if [[ ! -f "$done_marker" ]] && ! claude_is_running "$pid"; then
                    log_error "Task ${task_id}: agent process disappeared without completion marker (crash/OOM/SIGKILL)"
                    task_set_failed "$task_id" "Agent process crashed (no completion marker)"
                    _record_failure "$task_id" "Agent process crashed"
                    rm -f "$pid_file"
                    git_remove_worktree "$task_id"
                    continue
                fi

                # ── Check for timeout (before blocked — timeouts are not blocked) ──
                local timeout_marker="${output_file}.timeout"
                if [[ -f "$timeout_marker" ]]; then
                    local timeout_count current_model
                    timeout_count=$(jq -r '.timeout_count // 0' "${TASKS_DIR}/${task_id}.json" 2>/dev/null)
                    current_model=$(jq -r --arg def "$MODEL_SUPPORT" '.agent_model // $def' "${TASKS_DIR}/${task_id}.json" 2>/dev/null)

                    task_set_timeout "$task_id" "Agent timed out after ${DEFAULT_AGENT_TIMEOUT}s"
                    rm -f "$pid_file" "$done_marker" "$timeout_marker"
                    git_remove_worktree "$task_id"

                    if [[ "$timeout_count" -eq 0 ]] && [[ "$current_model" != "opus" ]]; then
                        # First timeout on sonnet → escalate to opus
                        log_warn "Task ${task_id}: timed out on ${current_model} — escalating to opus and retrying"
                        task_update "$task_id" "agent_model" "opus"
                        task_reset_pending "$task_id"
                    else
                        # Already on opus or second timeout → human problem
                        log_error "Task ${task_id}: timed out on ${current_model} (attempt $((timeout_count + 1))) — needs human intervention"
                        log_error "  Consider decomposing this task into smaller subtasks"
                        _record_failure "$task_id" "Timeout after model escalation"
                    fi
                    continue
                fi

                # ── Check for blocked status ───────────────────────
                local blocked_json
                blocked_json=$(parse_agent_json "$(cat "$output_file")" 2>/dev/null) || blocked_json=""
                if [[ -n "$blocked_json" ]] && echo "$blocked_json" | jq -e '.status == "blocked"' &>/dev/null; then
                    log_warn "Task ${task_id}: agent reported BLOCKED"

                    local uncertain_about
                    uncertain_about=$(echo "$blocked_json" | jq -r '.uncertain_about // "Unknown"' 2>/dev/null)
                    log_warn "  Uncertainty: ${uncertain_about}"

                    # Atomic: status + error + agent_pid in one write
                    task_set_blocked "$task_id" "$blocked_json"

                    # Invoke supervisor for blocked tasks
                    _invoke_supervisor "$task_id" "blocked"

                    rm -f "$pid_file" "$done_marker"
                    git_remove_worktree "$task_id"
                    continue
                fi

                # ── Normal completion check ───────────────────────
                # Resolve worktree path for this task
                local task_worktree="${WORKTREES_DIR}/task-${task_id}"

                if [[ -s "$output_file" ]]; then
                    log_success "Task ${task_id} agent completed"

                    if gates_run "$task_id" "$task_worktree"; then
                        # Atomic: status + completed_at + agent_pid in one write
                        task_set_done "$task_id"
                        log_success "Task ${task_id}: ${GREEN}DONE${RESET}"

                        # Extract decisions and concerns from agent output
                        # so downstream dependent tasks can see what this agent learned
                        local completion_json
                        completion_json=$(parse_agent_json "$(cat "$output_file")" 2>/dev/null) || completion_json=""
                        if [[ -n "$completion_json" ]] && echo "$completion_json" | jq -e '.status == "done"' &>/dev/null; then
                            local has_metadata
                            has_metadata=$(echo "$completion_json" | jq 'has("decisions") or has("concerns")' 2>/dev/null)
                            if [[ "$has_metadata" == "true" ]]; then
                                local tmp_task; tmp_task=$(mktemp)
                                jq --argjson dec "$(echo "$completion_json" | jq '.decisions // []')" \
                                   --argjson con "$(echo "$completion_json" | jq '.concerns // []')" \
                                    '.decisions = $dec | .concerns = $con' \
                                    "${TASKS_DIR}/${task_id}.json" > "$tmp_task" && mv "$tmp_task" "${TASKS_DIR}/${task_id}.json"
                            fi
                        fi

                        # Clean up worktree (frees the branch lock)
                        # NOTE: We do NOT merge into main here. Merging is deferred
                        # to just before spawning a dependent task, so in-flight agents
                        # are never disturbed by main moving underneath them.
                        git_remove_worktree "$task_id"
                    else
                        # Atomic: status + error + agent_pid in one write
                        task_set_failed "$task_id" "Quality gates failed"
                        log_error "Task ${task_id}: quality gates failed"
                        _record_failure "$task_id" "Quality gates failed"

                        # Keep worktree for debugger analysis
                        # (will be cleaned up on retry or recover)

                        # Invoke debugger for diagnosis
                        _invoke_debugger "$task_id"

                        # Check for pattern failures
                        local fail_count
                        fail_count=$(_failure_count)
                        if [[ "$fail_count" -ge "$PATTERN_FAILURE_THRESHOLD" ]]; then
                            log_warn "Multiple failures detected — invoking Supervisor for pattern analysis"
                            _invoke_supervisor "$task_id" "pattern"
                        fi
                    fi
                else
                    # Atomic: status + error + agent_pid in one write
                    task_set_failed "$task_id" "Agent produced no output"
                    log_error "Task ${task_id}: agent produced no output"
                    _record_failure "$task_id" "Agent produced no output"
                    git_remove_worktree "$task_id"
                fi

                # Clean up tracking
                rm -f "$pid_file" "$done_marker"
            fi
        done

        # Count running agents
        local running_count
        running_count=$(_running_count)

        # Find ready tasks and spawn agents
        local ready_tasks
        ready_tasks=$(_get_ready_tasks)

        if [[ -z "$ready_tasks" ]] && [[ $running_count -eq 0 ]]; then
            # Nothing ready and nothing running — check if blocked tasks exist
            local blocked_count
            blocked_count=$(task_count_by_status "blocked")
            if [[ "$blocked_count" -gt 0 ]]; then
                log_warn "${blocked_count} task(s) blocked — awaiting human input"
                log_warn "Run ${CYAN}tribe status${RESET} for supervisor analysis"
                break
            fi
            # Otherwise we're done
            break
        fi

        if [[ -n "$ready_tasks" ]]; then
            while IFS= read -r task_id; do
                if [[ $running_count -ge $max_parallel ]]; then
                    break
                fi

                # ── File conflict check ───────────────────────────
                local conflict_output
                conflict_output=$(grounding_check_file_conflicts "$task_id")
                if [[ $? -ne 0 ]] && [[ -n "$conflict_output" ]]; then
                    log_warn "Task ${task_id}: file conflict detected, deferring"
                    log_warn "  ${conflict_output}"
                    continue
                fi

                # Read task details
                local task_json
                task_json=$(task_get "$task_id")
                local title description criteria task_model branch
                title=$(echo "$task_json" | jq -r '.title')
                description=$(echo "$task_json" | jq -r '.description')
                criteria=$(echo "$task_json" | jq -r '.acceptance_criteria')
                task_model=$(echo "$task_json" | jq -r ".agent_model // \"${model}\"")
                branch=$(echo "$task_json" | jq -r '.branch')

                # Get files_touched for scope awareness
                local files_touched
                files_touched=$(echo "$task_json" | jq -r '.files_touched // [] | join(", ")')

                # Append review feedback if retrying
                local feedback
                feedback=$(echo "$task_json" | jq -r '.review_feedback // empty')
                local extra_context=""
                if [[ -n "$feedback" ]]; then
                    extra_context=$'\n\n## Previous Review Feedback\n\n'"${feedback}"
                fi

                # Append debugger analysis if retrying after failure
                local debugger_log="${LOGS_DIR}/debugger-${task_id}.json"
                if [[ -f "$debugger_log" ]]; then
                    extra_context+=$'\n\n## Debugger Analysis (from previous failure)\n\n'"$(cat "$debugger_log")"
                fi

                # Gather decisions and concerns from completed dependencies
                # so this agent knows what upstream agents learned and flagged
                local upstream_context=""
                local dep_ids_for_context
                dep_ids_for_context=$(echo "$task_json" | jq -r '.depends_on[]' 2>/dev/null)
                if [[ -n "$dep_ids_for_context" ]]; then
                    while IFS= read -r dep_id; do
                        [[ -z "$dep_id" ]] && continue
                        local dep_file="${TASKS_DIR}/${dep_id}.json"
                        [[ -f "$dep_file" ]] || continue
                        local dep_title dep_decisions dep_concerns
                        dep_title=$(jq -r '.title' "$dep_file")
                        dep_decisions=$(jq -r '.decisions // [] | if length > 0 then map("  - " + .) | join("\n") else empty end' "$dep_file" 2>/dev/null)
                        dep_concerns=$(jq -r '.concerns // [] | if length > 0 then map("  - " + .) | join("\n") else empty end' "$dep_file" 2>/dev/null)
                        if [[ -n "$dep_decisions" ]] || [[ -n "$dep_concerns" ]]; then
                            upstream_context+=$'\n'"#### Task ${dep_id}: ${dep_title}"
                            if [[ -n "$dep_decisions" ]]; then
                                upstream_context+=$'\n'"Decisions:"$'\n'"${dep_decisions}"
                            fi
                            if [[ -n "$dep_concerns" ]]; then
                                upstream_context+=$'\n'"Concerns:"$'\n'"${dep_concerns}"
                            fi
                        fi
                    done <<< "$dep_ids_for_context"
                fi
                if [[ -n "$upstream_context" ]]; then
                    extra_context+=$'\n\n## Context from Completed Dependencies\n'"${upstream_context}"
                fi

                # ── Deferred dependency merge ────────────────────
                # Merge completed dependency branches into main NOW, right
                # before creating this task's worktree. This ensures the new
                # worktree sees all predecessor work without ever disturbing
                # agents that are already running in their own worktrees.
                local dep_ids
                dep_ids=$(echo "$task_json" | jq -r '.depends_on[]' 2>/dev/null)
                if [[ -n "$dep_ids" ]]; then
                    local merge_failed=false
                    while IFS= read -r dep_id; do
                        [[ -z "$dep_id" ]] && continue
                        local dep_branch
                        dep_branch=$(jq -r '.branch' "${TASKS_DIR}/${dep_id}.json" 2>/dev/null)
                        [[ -z "$dep_branch" || "$dep_branch" == "null" ]] && continue
                        git_branch_exists "$dep_branch" || continue

                        # Skip if already merged into main
                        if _git merge-base --is-ancestor "$dep_branch" "$main_branch" 2>/dev/null; then
                            continue
                        fi

                        log_step "Deferred merge: ${dep_branch} → ${main_branch} (dependency of task ${task_id})"
                        if git_safe_merge "$dep_branch" "$main_branch"; then
                            log_success "Merged ${dep_branch} into ${main_branch}"
                        else
                            log_warn "Deferred merge failed for ${dep_branch} — deferring task ${task_id}"
                            merge_failed=true
                            break
                        fi
                    done <<< "$dep_ids"

                    if $merge_failed; then
                        continue  # skip this task, try again next loop iteration
                    fi
                fi

                # Create isolated worktree for this agent
                local worktree_path
                worktree_path=$(git_create_worktree "$task_id" "$branch")
                git_setup_worktree_deps "$worktree_path"

                # Build agent message
                local files_section=""
                if [[ -n "$files_touched" ]]; then
                    files_section="
### Declared Files (stay within scope)
${files_touched}"
                fi

                local agent_message="## Task: ${title}

### Description
${description}

### Acceptance Criteria
${criteria}
${files_section}

### Git Branch
You are working on branch: \`${branch}\`
You are already on this branch in an isolated worktree. Do NOT run git checkout.
Commit your work to this branch.${extra_context}

### Working Directory
${worktree_path}"

                # Spawn agent in the worktree directory
                local output_file="${LOGS_DIR}/${task_id}.log"
                local pid
                pid=$(claude_spawn_bg \
                    "${AGENTS_DIR}/developer.md" \
                    "$agent_message" \
                    "$output_file" \
                    "$task_model" \
                    "$AGENT_TOOLS_FULL" \
                    "$worktree_path")

                echo "$pid" > "${running_dir}/${task_id}.pid"

                # Atomic: status + started_at + agent_pid in one write
                task_set_running "$task_id" "$pid"
                ((running_count++))

                log_step "Spawned agent for task ${task_id}: ${CYAN}${title}${RESET} (PID: ${pid}, model: ${task_model})"

                # Update state file
                jq --arg tid "$task_id" --arg pid "$pid" \
                    '.agents += [{"task_id": $tid, "pid": ($pid | tonumber)}]' \
                    "$STATE_FILE" > "${STATE_FILE}.tmp" && mv "${STATE_FILE}.tmp" "$STATE_FILE"

            done <<< "$ready_tasks"
        fi

        # Brief status update
        local done_count pending_count failed_count blocked_count
        done_count=$(task_count_by_status "done")
        running_count=$(_running_count)
        pending_count=$(task_count_by_status "pending")
        failed_count=$(task_count_by_status "failed")
        blocked_count=$(task_count_by_status "blocked")
        echo -ne "\r${DIM}[${done_count}/${total} done | ${running_count} running | ${pending_count} pending | ${failed_count} failed | ${blocked_count} blocked]${RESET}  "

        # Check halt threshold
        local fail_pct=0
        if [[ "$total" -gt 0 ]]; then
            fail_pct=$(( (failed_count * 100) / total ))
        fi
        if [[ "$fail_pct" -ge "$HALT_FAILURE_PCT" ]]; then
            echo ""
            log_error "Over 30% of tasks have failed (${failed_count}/${total}). Halting swarm."
            log_error "Review failures with: tribe status"
            break
        fi

        # Sleep before next check
        sleep "$POLL_INTERVAL"
    done

    echo ""
    echo ""

    # Clean up
    rm -rf "$running_dir"

    # Final state update
    jq '.status = "idle" | .agents = []' "$STATE_FILE" > "${STATE_FILE}.tmp" && mv "${STATE_FILE}.tmp" "$STATE_FILE"

    # Print final summary
    log_header "Run Complete"
    task_print_graph
    echo ""
    task_print_summary
    echo ""

    local failed_count
    failed_count=$(task_count_by_status "failed")
    if [[ "$failed_count" -gt 0 ]]; then
        log_warn "${failed_count} task(s) failed. Diagnose with ${CYAN}tribe retry --task-id ID${RESET} then provide guidance with ${CYAN}--context${RESET}."
    fi

    local blocked_count
    blocked_count=$(task_count_by_status "blocked")
    if [[ "$blocked_count" -gt 0 ]]; then
        log_warn "${blocked_count} task(s) blocked. Run ${CYAN}tribe status${RESET} for details and supervisor analysis."
    fi

    local done_count
    done_count=$(task_count_by_status "done")
    if [[ "$done_count" -gt 0 ]]; then
        echo -e "Next: ${CYAN}./swarm/tribe review${RESET} then ${CYAN}./swarm/tribe coherence${RESET} then ${CYAN}./swarm/tribe integrate${RESET}"
    fi
    echo ""
}

# ── Get ready tasks: pending + deps met + not blocked ────────

_get_ready_tasks() {
    _ensure_jq
    local pending
    pending=$(task_list_by_status "pending")

    if [[ -z "$pending" ]]; then
        return
    fi

    while IFS= read -r id; do
        if task_deps_met "$id"; then
            echo "$id"
        fi
    done <<< "$pending"
}

# ── Invoke debugger on a failed task ─────────────────────────

_invoke_debugger() {
    local task_id="$1"
    local task_json
    task_json=$(task_get "$task_id")
    local title description criteria branch
    title=$(echo "$task_json" | jq -r '.title')
    description=$(echo "$task_json" | jq -r '.description')
    criteria=$(echo "$task_json" | jq -r '.acceptance_criteria')
    branch=$(echo "$task_json" | jq -r '.branch')

    local output_file="${LOGS_DIR}/${task_id}.log"
    local agent_output=""
    if [[ -f "$output_file" ]]; then
        # Tail last 200 lines to keep context manageable
        agent_output=$(tail -"$AGENT_OUTPUT_TAIL" "$output_file")
    fi

    local diff=""
    if git_branch_exists "$branch" 2>/dev/null; then
        diff=$(_git diff "$(git_main_branch)...${branch}" 2>/dev/null | head -"$DIFF_HEAD_LINES" || echo "No diff")
    fi

    local debugger_message="## Failed Task ${task_id}: ${title}

### Task Description
${description}

### Acceptance Criteria
${criteria}

### Agent Output (last 200 lines)
${agent_output}

### Git Diff (first 500 lines)
\`\`\`diff
${diff}
\`\`\`

Diagnose why this task failed and provide a specific fix."

    log_step "Invoking Debugger for task ${task_id}..."

    local debugger_output
    debugger_output=$(claude_run \
        "${AGENTS_DIR}/debugger.md" \
        "$debugger_message" \
        "$MODEL_SUPPORT" \
        "$AGENT_TOOLS_READONLY" 2>/dev/null || echo '{"error": "Debugger agent failed"}')

    local parsed_debugger
    parsed_debugger=$(parse_agent_json "$debugger_output") || parsed_debugger="$debugger_output"
    echo "$parsed_debugger" > "${LOGS_DIR}/debugger-${task_id}.json"
    log_step "Debugger analysis saved to ${LOGS_DIR}/debugger-${task_id}.json"
}

# ── Invoke supervisor for diagnosis ──────────────────────────

_invoke_supervisor() {
    local task_id="$1"
    local trigger_type="$2"  # "blocked", "pattern", "coherence", "contract"

    local task_json
    task_json=$(task_get "$task_id")

    # Gather swarm state
    local swarm_state=""
    swarm_state+="Total tasks: $(task_count_total)\n"
    swarm_state+="Done: $(task_count_by_status "done")\n"
    swarm_state+="Running: $(task_count_by_status "running")\n"
    swarm_state+="Pending: $(task_count_by_status "pending")\n"
    swarm_state+="Failed: $(task_count_by_status "failed")\n"
    swarm_state+="Blocked: $(task_count_by_status "blocked")\n"

    # Gather failure history
    local failure_history=""
    local failure_log="${FEATURE_DIR}/failure_history.jsonl"
    if [[ -f "$failure_log" ]]; then
        failure_history=$(cat "$failure_log")
    fi

    # Gather task details
    local task_details=""
    task_details+="Task ${task_id}: $(echo "$task_json" | jq -r '.title')\n"
    task_details+="Status: $(echo "$task_json" | jq -r '.status')\n"
    task_details+="Error: $(echo "$task_json" | jq -r '.error // "none"')\n"

    # Include debugger analysis if available
    local debugger_log="${LOGS_DIR}/debugger-${task_id}.json"
    if [[ -f "$debugger_log" ]]; then
        task_details+="\nDebugger Analysis:\n$(cat "$debugger_log")\n"
    fi

    local supervisor_message="## Supervisor Trigger: ${trigger_type}

### Swarm State
$(echo -e "$swarm_state")

### Triggering Task
$(echo -e "$task_details")

### Failure History
${failure_history}

Diagnose the situation and recommend recovery actions."

    log_step "Invoking Supervisor (trigger: ${trigger_type})..."

    local supervisor_output
    supervisor_output=$(claude_run \
        "${AGENTS_DIR}/supervisor.md" \
        "$supervisor_message" \
        "$MODEL_SUPPORT" \
        "$AGENT_TOOLS_READONLY" 2>/dev/null || echo '{"error": "Supervisor agent failed"}')

    local parsed_supervisor
    parsed_supervisor=$(parse_agent_json "$supervisor_output") || parsed_supervisor="$supervisor_output"
    local supervisor_log="${LOGS_DIR}/supervisor-${task_id}-$(date +%s).json"
    echo "$parsed_supervisor" > "$supervisor_log"
    _prune_logs "supervisor-${task_id}-" ".json"

    # ── Surface diagnosis to stdout ──────────────────────────────
    local diagnosis
    diagnosis=$(echo "$parsed_supervisor" | jq -r '.diagnosis // empty' 2>/dev/null)
    if [[ -n "$diagnosis" ]]; then
        echo ""
        echo -e "${BOLD}Supervisor Diagnosis:${RESET}"
        echo -e "  ${diagnosis}"
    fi

    # ── Surface pattern detection prominently ────────────────────
    local pattern_desc
    pattern_desc=$(echo "$parsed_supervisor" | jq -r '.pattern_detected.description // empty' 2>/dev/null)
    if [[ -n "$pattern_desc" ]]; then
        local root_cause affected
        root_cause=$(echo "$parsed_supervisor" | jq -r '.pattern_detected.root_cause // "Unknown"' 2>/dev/null)
        affected=$(echo "$parsed_supervisor" | jq -r '.pattern_detected.affected_tasks // [] | join(", ")' 2>/dev/null)
        echo ""
        echo -e "${RED}${BOLD}PATTERN DETECTED:${RESET} ${pattern_desc}"
        echo -e "  ${BOLD}Root cause:${RESET} ${root_cause}"
        echo -e "  ${BOLD}Affected tasks:${RESET} ${affected}"
    fi

    # ── Surface recommended actions ──────────────────────────────
    local action_count
    action_count=$(echo "$parsed_supervisor" | jq '[.actions // [] | .[]] | length' 2>/dev/null || echo "0")
    if [[ "$action_count" -gt 0 ]]; then
        echo ""
        echo -e "${BOLD}Supervisor Recommendations:${RESET}"
        echo "$parsed_supervisor" | jq -r '
            .actions[]? |
            "  \(.action) task \(.task_id // "?"): \(.reason // "no reason given")" +
            if .human_question then "\n    → HUMAN INPUT: \(.human_question)" else "" end +
            if .additional_context then "\n    → Context: \(.additional_context)" else "" end
        ' 2>/dev/null
    fi

    # ── Surface human-readable recommendations ───────────────────
    local rec_count
    rec_count=$(echo "$parsed_supervisor" | jq '[.recommendations // [] | .[]] | length' 2>/dev/null || echo "0")
    if [[ "$rec_count" -gt 0 ]]; then
        echo ""
        echo -e "${BOLD}Suggestions:${RESET}"
        echo "$parsed_supervisor" | jq -r '.recommendations[]? | "  • \(.)"' 2>/dev/null
    fi

    # ── Check if supervisor recommends halting ────────────────────
    local should_halt
    should_halt=$(echo "$parsed_supervisor" | jq -r '.should_halt' 2>/dev/null || echo "false")
    if [[ "$should_halt" == "true" ]]; then
        local halt_reason
        halt_reason=$(echo "$parsed_supervisor" | jq -r '.halt_reason' 2>/dev/null || echo "Unknown")
        echo ""
        log_error "Supervisor recommends HALTING: ${halt_reason}"
    fi

    echo ""
    log_step "Full analysis: ${supervisor_log}"
}

# ── Product Guardian: vision alignment check ──────────────────
# Runs the Product Guardian agent against any input (spec, diff, integration)
# Returns: 0 = aligned, 1 = rejected, 2 = flagged (warnings)
_run_guardian() {
    local check_type="$1"  # "pre-plan" | "post-review" | "post-integration"
    local content="$2"
    local label="${3:-}"

    local overview_file="${TRIBE_ROOT}/specs/product/overview.md"
    if [[ ! -f "$overview_file" ]]; then
        log_warn "Product overview not found at ${overview_file} — skipping guardian check"
        return 0
    fi

    local overview_content
    overview_content=$(cat "$overview_file")

    local guardian_message="## Guardian Check: ${check_type}

### Product Vision (source of truth)
${overview_content}

### Input to Evaluate
${content}

Evaluate this ${check_type} input against the product vision. Respond with JSON."

    log_step "Running Product Guardian (${check_type})..."

    local raw_guardian_output
    raw_guardian_output=$(claude_run \
        "${AGENTS_DIR}/product-guardian.md" \
        "$guardian_message" \
        "$MODEL_SUPPORT" \
        "$AGENT_TOOLS_READONLY")

    local guardian_output
    guardian_output=$(parse_agent_json "$raw_guardian_output") || guardian_output="$raw_guardian_output"

    # Save report
    local timestamp
    timestamp=$(date +%s)
    local log_file="${LOGS_DIR}/guardian-${check_type}-${timestamp}.json"
    echo "$guardian_output" > "$log_file"
    _prune_logs "guardian-${check_type}-" ".json"

    # Parse status
    local status
    status=$(echo "$guardian_output" | jq -r '.status' 2>/dev/null || echo "unknown")
    local summary
    summary=$(echo "$guardian_output" | jq -r '.summary' 2>/dev/null || echo "No summary")

    case "$status" in
        aligned)
            log_success "Guardian: ${GREEN}ALIGNED${RESET} — ${summary}"
            echo "$guardian_output"
            return 0
            ;;
        flagged)
            log_warn "Guardian: ${YELLOW}FLAGGED${RESET} — ${summary}"
            echo "$guardian_output"

            # Print flags
            local flag_count
            flag_count=$(echo "$guardian_output" | jq '.flags | length' 2>/dev/null || echo "0")
            if [[ "$flag_count" -gt 0 ]]; then
                echo ""
                echo -e "  ${BOLD}Vision Flags:${RESET}"
                echo "$guardian_output" | jq -r '.flags[] | "    \(.severity): \(.description)"' 2>/dev/null
                echo ""
            fi
            return 2
            ;;
        rejected)
            log_error "Guardian: ${RED}REJECTED${RESET} — ${summary}"
            echo "$guardian_output"

            # Print critical flags
            local critical_flags
            critical_flags=$(echo "$guardian_output" | jq -r '.flags[] | select(.severity == "critical") | "    \(.description)\n    Spec: \(.spec_reference)"' 2>/dev/null || echo "")
            if [[ -n "$critical_flags" ]]; then
                echo ""
                echo -e "  ${BOLD}Critical Violations:${RESET}"
                echo -e "$critical_flags"
                echo ""
            fi

            # Print Won't Have violations
            local wont_have
            wont_have=$(echo "$guardian_output" | jq -r '.wont_have_violations[]? | "    \(.feature) → maps to Won'\''t Have: \(.maps_to)"' 2>/dev/null || echo "")
            if [[ -n "$wont_have" ]]; then
                echo -e "  ${BOLD}Won't Have Violations:${RESET}"
                echo -e "$wont_have"
                echo ""
            fi
            return 1
            ;;
        *)
            log_warn "Guardian returned unparseable status. Review: ${log_file}"
            echo "$guardian_output"
            return 0
            ;;
    esac
}

# Standalone guardian command
cmd_guardian() {
    local input_file="${1:-}"

    log_header "Product Guardian"

    # If a file is provided, evaluate it (ad-hoc — no feature needed)
    if [[ -n "$input_file" ]]; then
        if [[ ! -f "$input_file" ]]; then
            if [[ -f "${TRIBE_ROOT}/${input_file}" ]]; then
                input_file="${TRIBE_ROOT}/${input_file}"
            else
                log_error "File not found: $input_file"
                exit 1
            fi
        fi

        # Use feature context for log output if available, else default LOGS_DIR
        feature_resolve "$GLOBAL_FEATURE" &>/dev/null && _require_feature "$GLOBAL_FEATURE" || mkdir -p "$LOGS_DIR"

        log_step "Evaluating: ${CYAN}${input_file}${RESET}"
        local content
        content=$(cat "$input_file")

        _run_guardian "ad-hoc" "$content" "$input_file"
        local rc=$?

        echo ""
        echo -e "Report saved to ${CYAN}${LOGS_DIR}/guardian-ad-hoc-*.json${RESET}"
        echo ""
        return $rc
    fi

    # No file — evaluate the current task plan + completed work (requires feature)
    _require_feature "$GLOBAL_FEATURE"

    local spec_file
    spec_file=$(_get_spec_path)
    if [[ -z "$spec_file" ]] || [[ ! -f "$spec_file" ]]; then
        log_error "No spec file found. Provide a file or run 'tribe plan' first."
        log_error "Usage: tribe guardian <spec-or-plan-file>"
        exit 1
    fi

    log_step "Evaluating current spec: ${CYAN}${spec_file}${RESET}"
    local content
    content=$(cat "$spec_file")

    # Include task plan if it exists
    local total
    total=$(task_count_total 2>/dev/null || echo "0")
    if [[ "$total" -gt 0 ]]; then
        content+="\n\n## Current Task Plan\n"
        for f in "${TASKS_DIR}"/*.json; do
            [[ -f "$f" ]] || continue
            local id title status
            id=$(jq -r '.id' "$f")
            title=$(jq -r '.title' "$f")
            status=$(jq -r '.status' "$f")
            content+="- Task ${id}: ${title} [${status}]\n"
        done
    fi

    _run_guardian "ad-hoc" "$content" "$spec_file"
    local rc=$?

    echo ""
    echo -e "Report saved to ${CYAN}${LOGS_DIR}/guardian-ad-hoc-*.json${RESET}"
    echo ""
    return $rc
}

cmd_status() {
    log_header "Swarm Status"

    # ── Feature overview ──────────────────────────────────────────
    local features
    features=$(feature_list)
    local active_feature
    active_feature=$(feature_get_active)

    if [[ -z "$features" ]]; then
        log_info "No features planned. Run 'tribe plan <spec>' to start."
        return
    fi

    echo -e "${BOLD}Features:${RESET}"
    while IFS= read -r feat; do
        [[ -z "$feat" ]] && continue
        local feat_dir="${FEATURES_DIR}/${feat}"
        local feat_done=0 feat_total=0 feat_running=0 feat_failed=0
        for f in "${feat_dir}/tasks/"*.json; do
            [[ -f "$f" ]] || continue
            ((feat_total++))
            local s
            s=$(jq -r '.status' "$f" 2>/dev/null)
            case "$s" in
                done) ((feat_done++)) ;;
                running) ((feat_running++)) ;;
                failed) ((feat_failed++)) ;;
            esac
        done
        local marker=""
        if [[ "$feat" == "$active_feature" ]]; then
            marker=" ${GREEN}(active)${RESET}"
        fi
        local progress="${feat_done}/${feat_total}"
        local detail=""
        if [[ $feat_running -gt 0 ]]; then detail+=", ${YELLOW}${feat_running} running${RESET}"; fi
        if [[ $feat_failed -gt 0 ]]; then detail+=", ${RED}${feat_failed} failed${RESET}"; fi
        echo -e "  ${CYAN}${feat}${RESET}${marker} — ${progress} done${detail}"
    done <<< "$features"
    echo ""

    # ── Detailed view for the target feature ──────────────────────
    # If --feature is specified, show that one. Otherwise show the active feature.
    local target_feature=""
    if [[ -n "$GLOBAL_FEATURE" ]]; then
        target_feature="$GLOBAL_FEATURE"
    elif [[ -n "$active_feature" ]] && [[ -d "${FEATURES_DIR}/${active_feature}" ]]; then
        target_feature="$active_feature"
    else
        # Show first feature if only one exists
        local feat_count
        feat_count=$(echo "$features" | grep -c . 2>/dev/null || echo "0")
        if [[ "$feat_count" -eq 1 ]]; then
            target_feature="$features"
        else
            echo -e "Use ${CYAN}--feature <name>${RESET} to see details for a specific feature."
            echo ""
            return
        fi
    fi

    feature_activate "$target_feature"
    echo -e "${BOLD}Showing: ${CYAN}${target_feature}${RESET}"
    echo ""

    # Check if initialized
    if [[ ! -d "$TASKS_DIR" ]]; then
        log_info "Feature '${target_feature}' has no tasks."
        return
    fi

    local total
    total=$(task_count_total)

    if [[ "$total" -eq 0 ]]; then
        log_info "No tasks. Run 'tribe plan <spec>' to create tasks."
        return
    fi

    # Task graph
    task_print_graph
    echo ""
    task_print_summary
    echo ""

    # State info
    if [[ -f "$STATE_FILE" ]]; then
        local swarm_status
        swarm_status=$(jq -r '.status' "$STATE_FILE")
        local agent_count
        agent_count=$(jq '.agents | length' "$STATE_FILE")

        echo -e "${BOLD}Swarm:${RESET} ${swarm_status} | Active agents: ${agent_count}"

        if [[ "$agent_count" -gt 0 ]]; then
            echo -e "${BOLD}Active Agents:${RESET}"
            jq -r '.agents[] | "  PID \(.pid) → Task \(.task_id)"' "$STATE_FILE"
        fi
    fi

    # Contract info
    if [[ -f "${CONTRACT_FILE}" ]]; then
        echo -e "${BOLD}Contract:${RESET} ${GREEN}present${RESET}"
    else
        echo -e "${BOLD}Contract:${RESET} ${YELLOW}missing${RESET}"
    fi

    # Blocked tasks
    local blocked_count
    blocked_count=$(task_count_by_status "blocked")
    if [[ "$blocked_count" -gt 0 ]]; then
        echo ""
        echo -e "${BOLD}Blocked Tasks (need human input):${RESET}"
        for f in "${TASKS_DIR}"/*.json; do
            [[ -f "$f" ]] || continue
            local status
            status=$(jq -r '.status' "$f")
            if [[ "$status" == "blocked" ]]; then
                local id title error
                id=$(jq -r '.id' "$f")
                title=$(jq -r '.title' "$f")
                error=$(jq -r '.error // "No details"' "$f")
                echo -e "  ${YELLOW}${SYM_WARN}${RESET} Task ${id}: ${title}"
                echo -e "    ${DIM}${error}${RESET}"
            fi
        done
    fi

    # Timed-out tasks (failed after timeout escalation — need decomposition)
    local has_timeouts=false
    for f in "${TASKS_DIR}"/*.json; do
        [[ -f "$f" ]] || continue
        local tc
        tc=$(jq -r '.timeout_count // 0' "$f")
        if [[ "$tc" -gt 0 ]]; then
            if ! $has_timeouts; then
                echo ""
                echo -e "${BOLD}Timed-Out Tasks (consider decomposing):${RESET}"
                has_timeouts=true
            fi
            local id title model tc_val status
            id=$(jq -r '.id' "$f")
            title=$(jq -r '.title' "$f")
            model=$(jq -r --arg def "$MODEL_SUPPORT" '.agent_model // $def' "$f")
            tc_val=$(jq -r '.timeout_count' "$f")
            status=$(jq -r '.status' "$f")
            echo -e "  ${YELLOW}${SYM_WARN}${RESET} Task ${id}: ${title} ${DIM}(${tc_val}x timeout, model: ${model}, status: ${status})${RESET}"
        fi
    done

    # Latest supervisor analysis (show the most recent log if it exists)
    local latest_supervisor
    latest_supervisor=$(ls -t "${LOGS_DIR}"/supervisor-*.json 2>/dev/null | head -1 || true)
    if [[ -n "$latest_supervisor" ]] && [[ -f "$latest_supervisor" ]]; then
        local sup_diagnosis sup_pattern sup_recommendations
        sup_diagnosis=$(jq -r '.diagnosis // empty' "$latest_supervisor" 2>/dev/null)
        sup_pattern=$(jq -r '.pattern_detected.description // empty' "$latest_supervisor" 2>/dev/null)
        sup_recommendations=$(jq -r '[.recommendations // [] | .[]] | length' "$latest_supervisor" 2>/dev/null || echo "0")

        if [[ -n "$sup_diagnosis" ]] || [[ -n "$sup_pattern" ]]; then
            echo ""
            echo -e "${BOLD}Latest Supervisor Analysis:${RESET}"
            if [[ -n "$sup_diagnosis" ]]; then
                echo -e "  ${DIM}Diagnosis:${RESET} ${sup_diagnosis}"
            fi
            if [[ -n "$sup_pattern" ]]; then
                local sup_root_cause
                sup_root_cause=$(jq -r '.pattern_detected.root_cause // "Unknown"' "$latest_supervisor" 2>/dev/null)
                echo -e "  ${RED}Pattern:${RESET} ${sup_pattern}"
                echo -e "  ${RED}Root cause:${RESET} ${sup_root_cause}"
            fi
            if [[ "$sup_recommendations" -gt 0 ]]; then
                echo -e "  ${DIM}Suggestions:${RESET}"
                jq -r '.recommendations[]? | "    • \(.)"' "$latest_supervisor" 2>/dev/null
            fi
            echo -e "  ${DIM}Full log: ${latest_supervisor}${RESET}"
        fi
    fi

    echo ""
}

# ── Coherence: cross-task consistency check ──────────────────

cmd_coherence() {
    _require_feature "$GLOBAL_FEATURE"
    log_header "Coherence Check"

    local done_tasks
    done_tasks=$(task_list_by_status "done")

    if [[ -z "$done_tasks" ]]; then
        log_info "No completed tasks to check."
        return
    fi

    # Gather all diffs from completed tasks
    local all_diffs=""
    local task_count=0
    while IFS= read -r tid; do
        local task_json
        task_json=$(task_get "$tid")
        local title branch
        title=$(echo "$task_json" | jq -r '.title')
        branch=$(echo "$task_json" | jq -r '.branch')

        local diff=""
        if git_branch_exists "$branch"; then
            diff=$(git_diff_branch "$branch" 2>/dev/null || echo "No diff")
        fi

        all_diffs+="
--- TASK ${tid}: ${title} (branch: ${branch}) ---
\`\`\`diff
${diff}
\`\`\`

"
        ((task_count++))
    done <<< "$done_tasks"

    # Gather product spec
    local spec_content=""
    local spec_file
    spec_file=$(_get_spec_path)
    if [[ -n "$spec_file" ]] && [[ -f "$spec_file" ]]; then
        spec_content=$(cat "$spec_file")
    fi

    # Gather contract
    local contract_content=""
    if [[ -f "${CONTRACT_FILE}" ]]; then
        contract_content=$(cat "${CONTRACT_FILE}")
    fi

    local coherence_message="## Coherence Check: ${task_count} completed tasks

### All Task Diffs
${all_diffs}

### Product Specification
${spec_content}

### Data Model Contract
${contract_content}

Check that all these task implementations compose correctly. Focus on interfaces, schemas, naming consistency, duplicates, and missing connections."

    log_step "Sending ${task_count} task diffs to Coherence Checker..."
    echo ""

    local coherence_output
    coherence_output=$(claude_run \
        "${AGENTS_DIR}/coherence-checker.md" \
        "$coherence_message" \
        "$MODEL_PLANNING" \
        "$AGENT_TOOLS_READONLY")

    echo "$coherence_output"
    echo ""

    # Parse and save report
    local parsed_coherence
    parsed_coherence=$(parse_agent_json "$coherence_output") || parsed_coherence="$coherence_output"
    echo "$parsed_coherence" > "${LOGS_DIR}/coherence.log"
    log_success "Coherence report saved to ${LOGS_DIR}/coherence.log"

    local status
    status=$(echo "$parsed_coherence" | jq -r '.status' 2>/dev/null || echo "unknown")

    if [[ "$status" == "fail" ]]; then
        echo ""
        log_error "Coherence check FAILED — tasks have compatibility issues"
        local issue_count
        issue_count=$(echo "$parsed_coherence" | jq '.critical_issues | length' 2>/dev/null || echo "?")
        log_error "${issue_count} critical issue(s) found"
        echo ""
        echo -e "Fix issues before integrating. Options:"
        echo -e "  1. ${CYAN}tribe retry --task-id ID --context \"...\"${RESET} to fix specific tasks"
        echo -e "  2. Review the coherence report and fix manually"
        exit 1
    elif [[ "$status" == "pass" ]]; then
        echo ""
        log_success "Coherence check PASSED — tasks are compatible"
        echo -e "Next: ${CYAN}./swarm/tribe integrate${RESET}"
    else
        log_warn "Could not parse coherence status. Review the report manually."
    fi

    echo ""
}

cmd_integrate() {
    _require_feature "$GLOBAL_FEATURE"
    # ── Acquire exclusive lock ────────────────────────────────────
    swarm_acquire_lock "integrate" || exit 1

    log_header "Integrating Completed Work"

    # Check for circular dependencies
    if ! task_topo_sort > /dev/null; then
        log_error "Cannot integrate: circular dependencies in task graph."
        exit 1
    fi

    local done_tasks
    done_tasks=$(task_list_by_status "done")

    if [[ -z "$done_tasks" ]]; then
        log_info "No completed tasks to integrate."
        return
    fi

    # Get branches in topological order
    local branches=()
    local ordered_tasks
    ordered_tasks=$(task_topo_sort)

    while IFS= read -r task_id; do
        local status
        status=$(jq -r '.status' "${TASKS_DIR}/${task_id}.json" 2>/dev/null)
        if [[ "$status" == "done" ]]; then
            local branch
            branch=$(jq -r '.branch' "${TASKS_DIR}/${task_id}.json")
            if git_branch_exists "$branch"; then
                # Skip branches already merged (idempotent)
                if _git merge-base --is-ancestor "$branch" "$(git_main_branch)" 2>/dev/null; then
                    log_step "Branch ${branch} already merged — skipping"
                    continue
                fi
                branches+=("$branch")
            fi
        fi
    done <<< "$ordered_tasks"

    if [[ ${#branches[@]} -eq 0 ]]; then
        log_info "No branches to merge."
        return
    fi

    log_step "Merging ${#branches[@]} branches in dependency order..."
    echo ""

    # Build branch list for integrator
    local branch_list=""
    for b in "${branches[@]}"; do
        branch_list+="- ${b}"$'\n'
    done

    local integrate_branch
    integrate_branch=$(git_main_branch)

    local agent_message="## Integration Task

Merge the following branches into ${integrate_branch}, in the order listed (dependency order):

${branch_list}

### Working Directory
${TRIBE_ROOT}

### Instructions
1. For each branch, checkout ${integrate_branch}, then merge the branch with --no-ff
2. If there are merge conflicts, resolve them intelligently
3. After each merge, verify the code still works
4. Report results as JSON"

    log_step "Sending to Integrator agent..."

    local output
    output=$(claude_run \
        "${AGENTS_DIR}/integrator.md" \
        "$agent_message" \
        "$MODEL_SUPPORT" \
        "$AGENT_TOOLS_FULL")

    echo "$output"
    echo ""

    # Save integration log
    echo "$output" > "${LOGS_DIR}/integration.log"
    log_success "Integration log saved to ${LOGS_DIR}/integration.log"

    # ── Post-integration: regression tests ────────────────────────
    echo ""
    log_header "Post-Integration Verification"

    if regression_run; then
        log_success "Regression tests passed"
    else
        log_error "Regression tests FAILED after integration"
        log_error "The merge may have introduced incompatibilities"
        echo ""
        echo -e "Options:"
        echo -e "  1. Check ${CYAN}${LOGS_DIR}/integration.log${RESET} for details"
        echo -e "  2. Use ${CYAN}git log --oneline${RESET} to review merge commits"
        echo -e "  3. Use ${CYAN}git reset --hard HEAD~N${RESET} to rollback (destructive)"
        echo ""
    fi

    # ── Post-integration: contract check ──────────────────────────
    if [[ -f "${CONTRACT_FILE}" ]]; then
        if contract_check; then
            log_success "Contract check passed — schema matches plan"
        else
            log_error "Contract check FAILED — built schema doesn't match the plan"
            log_error "This means the implementation doesn't support the product's core question"
            echo ""

            # Invoke supervisor for contract failure
            _invoke_supervisor "0" "contract"
        fi
    fi

    # ── Post-integration: Guardian vision check ──────────────────
    # Check: does the integrated result still feel like FYT?
    if [[ "${SKIP_GUARDIAN:-}" != "true" ]]; then
        echo ""
        log_header "Post-Integration Vision Check"

        # Gather the full integration diff
        local integration_diff=""
        for b in "${branches[@]}"; do
            integration_diff+="--- Branch: ${b} ---"$'\n'
            integration_diff+=$(git_diff_branch "$b" 2>/dev/null || echo "No diff")$'\n\n'
        done

        # Include the spec for context
        local spec_content=""
        local spec_file
        spec_file=$(_get_spec_path)
        if [[ -n "$spec_file" ]] && [[ -f "$spec_file" ]]; then
            spec_content="
### Feature Specification
$(cat "$spec_file")"
        fi

        local guardian_input="## Integrated Work: ${#branches[@]} branches merged

### Combined Diff
${integration_diff}
${spec_content}

This is a post-integration check. Evaluate whether the integrated result, taken as a whole, is consistent with the product vision."

        _run_guardian "post-integration" "$guardian_input" "integration" || {
            local grc=$?
            if [[ $grc -eq 1 ]]; then
                echo ""
                log_error "Guardian REJECTED the integrated result — vision violation detected"
                log_error "Review the guardian report before shipping"
                echo -e "Report: ${CYAN}${LOGS_DIR}/guardian-post-integration-*.json${RESET}"
            fi
        }
    fi

    echo ""
}

cmd_review() {
    _require_feature "$GLOBAL_FEATURE"
    local task_id=""

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --task-id) task_id="$2"; shift 2 ;;
            *) log_error "Unknown option: $1"; exit 1 ;;
        esac
    done

    log_header "Code Review"

    # If no task specified, review all done tasks
    local tasks_to_review
    if [[ -n "$task_id" ]]; then
        tasks_to_review="$task_id"
    else
        tasks_to_review=$(task_list_by_status "done")
    fi

    if [[ -z "$tasks_to_review" ]]; then
        log_info "No completed tasks to review."
        return
    fi

    while IFS= read -r tid; do
        local task_json
        task_json=$(task_get "$tid")
        local title branch criteria
        title=$(echo "$task_json" | jq -r '.title')
        branch=$(echo "$task_json" | jq -r '.branch')
        criteria=$(echo "$task_json" | jq -r '.acceptance_criteria')

        log_step "Reviewing task ${tid}: ${CYAN}${title}${RESET}"

        # Get the diff
        local diff=""
        if git_branch_exists "$branch"; then
            diff=$(git_diff_branch "$branch" 2>/dev/null || echo "No diff available")
        else
            log_warn "Branch ${branch} not found, skipping"
            continue
        fi

        # Gather product specs for context (if specs/ directory exists)
        local spec_context=""
        local spec_file
        spec_file=$(_get_spec_path)
        if [[ -n "$spec_file" ]] && [[ -f "$spec_file" ]]; then
            spec_context="
### Product Specification (SOURCE OF TRUTH — verify code satisfies this)
$(cat "$spec_file")"
        fi

        # Also include other specs if available
        local specs_dir="${TRIBE_ROOT}/specs"
        if [[ -d "$specs_dir" ]]; then
            while IFS= read -r -d '' sf; do
                local relpath="${sf#${TRIBE_ROOT}/}"
                # Skip the primary spec (already included above)
                if [[ -n "$spec_file" ]] && [[ "$(realpath "$sf")" == "$(realpath "$spec_file")" ]]; then
                    continue
                fi
                spec_context+=$'\n\n'"--- RELATED SPEC: ${relpath} ---"$'\n'"$(cat "$sf")"
            done < <(find "$specs_dir" -name '*.md' -type f -print0 | sort -z)
        fi

        local agent_message="## Review Task ${tid}: ${title}

### Acceptance Criteria
${criteria}

### Git Diff (branch: ${branch})
\`\`\`diff
${diff}
\`\`\`
${spec_context}

### Instructions
1. Read the Product Specification FIRST — form your understanding of what this code should do
2. Check the diff against the spec — quote specific spec lines for each requirement you verify
3. Flag anything in the diff that doesn't trace to a spec requirement (potential over-engineering)
4. Then do standard code review (quality, conventions, security, tests)
Respond with your review as JSON."

        local review_output
        review_output=$(claude_run \
            "${AGENTS_DIR}/reviewer.md" \
            "$agent_message" \
            "$MODEL_SUPPORT" \
            "$AGENT_TOOLS_READONLY")

        echo ""
        echo "$review_output"
        echo ""

        # Parse and save review
        local parsed_review
        parsed_review=$(parse_agent_json "$review_output") || parsed_review="$review_output"
        echo "$parsed_review" > "${LOGS_DIR}/review-${tid}.json"

        # Check verdict
        local verdict
        verdict=$(echo "$parsed_review" | jq -r '.verdict' 2>/dev/null || echo "unknown")
        if [[ "$verdict" == "request_changes" ]]; then
            log_warn "Task ${tid}: changes requested"
            # Atomic: status + review_feedback in one write
            task_request_changes "$tid" "$parsed_review"
        elif [[ "$verdict" == "approve" ]]; then
            log_success "Task ${tid}: approved by Reviewer"

            # ── Post-Review Guardian Gate ──────────────────────────
            # Check: did the implementation drift from the vision?
            if [[ "${SKIP_GUARDIAN:-}" != "true" ]]; then
                local guardian_input="## Task ${tid}: ${title}

### Code Diff (branch: ${branch})
\`\`\`diff
${diff}
\`\`\`

### Task Acceptance Criteria
${criteria}"

                _run_guardian "post-review" "$guardian_input" "task-${tid}" || {
                    local grc=$?
                    if [[ $grc -eq 1 ]]; then
                        log_error "Task ${tid}: Guardian REJECTED — vision violation in implementation"
                        local guardian_log
                        guardian_log=$(ls -t "${LOGS_DIR}"/guardian-post-review-*.json 2>/dev/null | head -1)
                        # Atomic: status + review_feedback in one write
                        task_request_changes "$tid" "GUARDIAN REJECTED: $(cat "$guardian_log" 2>/dev/null | jq -r '.summary' 2>/dev/null || echo 'See guardian log')"
                        verdict="request_changes"
                    fi
                    # grc == 2 means flagged — warn but keep approved
                }
            fi
        fi

    done <<< "$tasks_to_review"

    echo ""
}

cmd_retry() {
    _require_feature "$GLOBAL_FEATURE"
    local task_id=""
    local escalate=false
    local context=""

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --task-id)  task_id="$2"; shift 2 ;;
            --escalate) escalate=true; shift ;;
            --context)  context="$2"; shift 2 ;;
            *) log_error "Unknown option: $1"; exit 1 ;;
        esac
    done

    if [[ -z "$task_id" ]]; then
        log_error "Required: --task-id ID"
        log_error "Retry requires targeting a specific task. Use ${CYAN}tribe status${RESET} to see failed tasks."
        exit 1
    fi

    if [[ -z "$context" ]]; then
        # Show the failure details so the human can diagnose
        local task_json
        task_json=$(task_get "$task_id")
        local title error_msg status retry_count
        title=$(echo "$task_json" | jq -r '.title')
        error_msg=$(echo "$task_json" | jq -r '.error // "No error details"')
        status=$(echo "$task_json" | jq -r '.status')
        retry_count=$(echo "$task_json" | jq -r '.retry_count // 0')

        echo ""
        echo -e "${BOLD}Task ${task_id}:${RESET} ${title}"
        echo -e "${BOLD}Status:${RESET} ${status}"
        echo -e "${BOLD}Error:${RESET} ${error_msg}"
        echo -e "${BOLD}Previous retries:${RESET} ${retry_count}"

        # Show debugger analysis if available
        local debugger_log="${LOGS_DIR}/debugger-${task_id}.json"
        if [[ -f "$debugger_log" ]]; then
            echo ""
            echo -e "${BOLD}Debugger analysis:${RESET}"
            echo -e "  ${DIM}$(cat "$debugger_log" | jq -r '.root_cause // .diagnosis // "See full log"' 2>/dev/null)${RESET}"
        fi

        echo ""
        log_error "Blind retries are not allowed. Diagnose the failure and provide guidance:"
        echo -e "  ${CYAN}tribe retry --task-id ${task_id} --context \"what to do differently\"${RESET}"
        echo ""
        exit 1
    fi

    local task_json
    task_json=$(task_get "$task_id")
    local title current_model error_msg status
    title=$(echo "$task_json" | jq -r '.title')
    current_model=$(echo "$task_json" | jq -r '.agent_model')
    error_msg=$(echo "$task_json" | jq -r '.error // "No error details"')
    status=$(echo "$task_json" | jq -r '.status')

    if [[ "$status" != "failed" ]] && [[ "$status" != "blocked" ]]; then
        log_error "Task ${task_id} is '${status}', not failed or blocked. Nothing to retry."
        exit 1
    fi

    log_step "Retrying task ${task_id}: ${CYAN}${title}${RESET}"

    # Accumulate attempt history — append, never overwrite
    local prev_feedback
    prev_feedback=$(echo "$task_json" | jq -r '.review_feedback // ""')
    local retry_count
    retry_count=$(echo "$task_json" | jq -r '.retry_count // 0')
    local attempt_entry
    attempt_entry="--- Attempt $((retry_count + 1)) ---\nFailed with: ${error_msg}\nHuman guidance: ${context}"

    local accumulated_feedback
    if [[ -n "$prev_feedback" ]]; then
        accumulated_feedback="${prev_feedback}\n\n${attempt_entry}"
    else
        accumulated_feedback="$attempt_entry"
    fi
    task_update "$task_id" "review_feedback" "$(echo -e "$accumulated_feedback")"

    # Escalate model if requested
    if $escalate; then
        local new_model
        case "$current_model" in
            haiku)  new_model="sonnet" ;;
            sonnet) new_model="opus" ;;
            opus)   new_model="opus" ;;
        esac
        task_update "$task_id" "agent_model" "$new_model"
        log_info "Escalated model: ${current_model} → ${new_model}"
    fi

    # Clean up stale worktree if present
    git_remove_worktree "$task_id"

    # Atomic reset to pending (increments retry_count)
    task_reset_pending "$task_id"

    log_success "Task ${task_id} reset to pending (attempt $((retry_count + 2)))"

    echo ""
    echo -e "Run ${CYAN}./swarm/tribe run${RESET} to execute."
    echo ""
}

# ── Recover: fix stale state from crashed swarm ──────────────

cmd_recover() {
    _require_feature "$GLOBAL_FEATURE"
    log_header "Recovering Swarm State"

    # Force-break any stale lock
    swarm_force_break_lock

    local running_dir="${FEATURE_DIR}/running"
    local recovered=0

    # Clean stale PID files
    if [[ -d "$running_dir" ]]; then
        for pid_file in "$running_dir"/*.pid; do
            [[ -f "$pid_file" ]] || continue
            local task_id pid
            task_id=$(basename "$pid_file" .pid)
            pid=$(cat "$pid_file")

            if ! kill -0 "$pid" 2>/dev/null; then
                log_step "Cleaning stale PID file for task ${task_id} (PID ${pid} not running)"
                rm -f "$pid_file"
                rm -f "${LOGS_DIR}/${task_id}.log.done"
                ((recovered++))
            fi
        done
    fi

    # Reset "running" tasks that have no active process
    for f in "${TASKS_DIR}"/*.json; do
        [[ -f "$f" ]] || continue
        local status tid
        status=$(jq -r '.status' "$f")
        tid=$(jq -r '.id' "$f")

        if [[ "$status" == "running" ]]; then
            local agent_pid
            agent_pid=$(jq -r '.agent_pid // "null"' "$f")
            if [[ "$agent_pid" == "null" ]] || ! kill -0 "$agent_pid" 2>/dev/null; then
                log_step "Resetting stale running task ${tid} to pending"
                task_reset_pending "$tid"
                git_remove_worktree "$tid"
                ((recovered++))
            fi
        fi
    done

    # Reset swarm state
    jq '.status = "idle" | .agents = []' "$STATE_FILE" > "${STATE_FILE}.tmp" && mv "${STATE_FILE}.tmp" "$STATE_FILE"

    # Clean up orphaned worktrees
    git_cleanup_worktrees

    if [[ "$recovered" -gt 0 ]]; then
        log_success "Recovered ${recovered} stale item(s)"
    else
        log_info "No stale state found — swarm is clean"
    fi

    echo ""
    task_print_summary
    echo ""
}

# ── Clean ─────────────────────────────────────────────────────────

cmd_clean() {
    local what="${1:-logs}"

    case "$what" in
        logs)
            # If a feature is specified or active, clean that feature's logs
            if feature_resolve "$GLOBAL_FEATURE" &>/dev/null; then
                _require_feature "$GLOBAL_FEATURE"
                local file_count size_before
                file_count=$(ls -1 "$LOGS_DIR" 2>/dev/null | wc -l | tr -d ' ')
                size_before=$(du -sh "$LOGS_DIR" 2>/dev/null | cut -f1)
                rm -rf "$LOGS_DIR"
                mkdir -p "$LOGS_DIR"
                log_success "Cleaned ${file_count} log files (${size_before}) for feature ${FEATURE_NAME}"
            else
                # Clean logs across all features
                local total_cleaned=0
                for feat_dir in "${FEATURES_DIR}"/*/logs; do
                    [[ -d "$feat_dir" ]] || continue
                    local fc
                    fc=$(ls -1 "$feat_dir" 2>/dev/null | wc -l | tr -d ' ')
                    total_cleaned=$((total_cleaned + fc))
                    rm -rf "$feat_dir"
                    mkdir -p "$feat_dir"
                done
                # Also clean top-level logs
                if [[ -d "${TRIBE_DIR}/logs" ]]; then
                    local fc
                    fc=$(ls -1 "${TRIBE_DIR}/logs" 2>/dev/null | wc -l | tr -d ' ')
                    total_cleaned=$((total_cleaned + fc))
                    rm -rf "${TRIBE_DIR}/logs"
                    mkdir -p "${TRIBE_DIR}/logs"
                fi
                log_success "Cleaned ${total_cleaned} log files across all features"
            fi
            ;;

        feature)
            local feat_name="${2:-}"
            if [[ -z "$feat_name" ]]; then
                log_error "Usage: tribe clean feature <name>"
                echo ""
                echo "Available features:"
                feature_list | while IFS= read -r f; do echo "  - $f"; done
                exit 1
            fi
            local feat_dir="${FEATURES_DIR}/${feat_name}"
            if [[ ! -d "$feat_dir" ]]; then
                log_error "Feature '${feat_name}' not found"
                exit 1
            fi
            # Clean worktrees for this feature
            local wt_dir="${TRIBE_DIR}/worktrees/${feat_name}"
            if [[ -d "$wt_dir" ]]; then
                for wt in "$wt_dir"/task-*; do
                    [[ -d "$wt" ]] || continue
                    git -C "$TRIBE_ROOT" worktree remove --force "$wt" 2>/dev/null || rm -rf "$wt"
                done
                git -C "$TRIBE_ROOT" worktree prune 2>/dev/null || true
            fi
            local size_before
            size_before=$(du -sh "$feat_dir" 2>/dev/null | cut -f1)
            rm -rf "$feat_dir" "$wt_dir"
            # Clear active feature if it was the one we deleted
            if [[ "$(feature_get_active)" == "$feat_name" ]]; then
                rm -f "${TRIBE_DIR}/active_feature"
            fi
            log_success "Cleaned feature '${feat_name}' (${size_before})"
            ;;

        all)
            if [[ ! -d "$TRIBE_DIR" ]]; then
                log_info "No .tribe directory — nothing to clean"
                return 0
            fi

            # Clean all worktrees (iterate all feature worktree dirs)
            if [[ -d "${TRIBE_DIR}/worktrees" ]]; then
                for wt_dir in "${TRIBE_DIR}"/worktrees/*/task-* "${TRIBE_DIR}"/worktrees/task-*; do
                    [[ -d "$wt_dir" ]] || continue
                    git -C "$TRIBE_ROOT" worktree remove --force "$wt_dir" 2>/dev/null || rm -rf "$wt_dir"
                done
                git -C "$TRIBE_ROOT" worktree prune 2>/dev/null || true
            fi

            local size_before
            size_before=$(du -sh "$TRIBE_DIR" 2>/dev/null | cut -f1)

            rm -rf "$TRIBE_DIR"
            log_success "Cleaned entire .tribe/ directory (${size_before})"
            ;;

        *)
            echo -e "Usage: ${CYAN}./swarm/tribe clean${RESET} [logs|feature <name>|all]"
            echo ""
            echo -e "  ${CYAN}logs${RESET}               Remove log files (active feature or all)"
            echo -e "  ${CYAN}feature <name>${RESET}      Remove a specific feature's state and worktrees"
            echo -e "  ${CYAN}all${RESET}                Remove entire .tribe/ directory"
            ;;
    esac
}

# ── Main ─────────────────────────────────────────────────────────

main() {
    local command="${1:-help}"
    shift || true

    # ── Extract global --feature flag before dispatching ──────────
    GLOBAL_FEATURE=""
    local args=()
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --feature|-f) GLOBAL_FEATURE="$2"; shift 2 ;;
            *) args+=("$1"); shift ;;
        esac
    done
    set -- "${args[@]+"${args[@]}"}"

    case "$command" in
        init)      cmd_init "$@" ;;
        validate)  cmd_validate "$@" ;;
        plan)      cmd_plan "$@" ;;
        verify)    cmd_verify "$@" ;;
        run)       cmd_run "$@" ;;
        status)    cmd_status "$@" ;;
        coherence) cmd_coherence "$@" ;;
        integrate) cmd_integrate "$@" ;;
        review)    cmd_review "$@" ;;
        retry)     cmd_retry "$@" ;;
        recover)   cmd_recover "$@" ;;
        guardian)   cmd_guardian "$@" ;;
        clean)     cmd_clean "$@" ;;
        help|--help|-h) tribe_help ;;
        *)
            log_error "Unknown command: ${command}"
            tribe_help
            exit 1
            ;;
    esac
}

main "$@"
